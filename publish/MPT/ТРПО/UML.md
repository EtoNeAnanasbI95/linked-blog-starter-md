**UML** - унифицированный язык моделирования

* Создатели:
	* Гарди Буч – сложные системы
	* Джеймс Рамбо – анализ требований
	* Айвар Джекобсон – делал все, объединил всех

* Структурная диаграмма - показывает, как будет выглядеть приложение со стороны разработчика
* Диаграмма поведение - показывает нам как будет вести себя приложение при конкретных действиях пользователя
* Диаграмма состояния - показывает нам как будет выглядеть программа в определённый момент времени

---
**Основные понятия языка UML** – объект, класс, ассоциация.
	**Объект** – это сущность реального мира или концептуальная сущность или программная единица, которая состоит из атрибутов (полей) и методов для их обработки.
	**Класс** – это описание множества объектов с общими атрибутами, которые определяют состояние и операциями, которые определяют поведение.
	**Ассоциации** — это наиболее общий тип отношений первого рода, связанный с передачей сообщений который ассоциируется классом путем делегирования.
**DFD** – это диаграммы потоков данных

![[Pasted image 20250918011149.png]]

В методологии DFD используется 4 типа структурных элементов - процессы, потоки данных, внешние сущности (от кого идет стрелка), хранилище

DFD диаграмма помогает разбить потоки данных на систему а так же представить их в виде сети связанной потоками данных

![[Pasted image 20250918011216.png]]

![[Pasted image 20250918011224.png]]
**Сущность** – это материальный объект или физическое лицо, выступающее как источник или приемник информации.
![[Pasted image 20250918011255.png]]

 **Процессы** (функция или работа) – представляет собой преобразование входных потоков данных в выходные в соответствии с определенным алгоритмом.
![[Pasted image 20250918011318.png]]
Каждый процесс должен иметь имя в виде предложения с глаголом в неопределенной форме (записаться, создать, сформировать).

Функция должна иметь уникальное имя.
![[Pasted image 20250918011331.png]]
![[Pasted image 20250918011342.png]]
Потоки данных определяют информацию, которая передается через некоторое соединение от источника к приемнику.

Каждая стрелка должна иметь надпись о том что мы передаем.
![[Pasted image 20250918011351.png]]
![[Pasted image 20250918011400.png]]
![[Pasted image 20250918011412.png]]
1 уровень DFD диаграммы – контекстный, который показывает обобщающее действие сущности

Для каждого процесса контекстной диаграммы может быть произведена декомпозиция, которая может быть раскрыта подробнее.
![[Pasted image 20250918011421.png]]
![[Pasted image 20250918011430.png]]
  
# Диаграмма классов
Диаграмма классов является дальнейшим развитием концептуальной модели проектируемой системы.

## Понятие диаграммы классов
**Класс** – это элемент диаграммы, обозначающий множество объектов, обладающих одинаковой внутренней структурой а так же поведением и отношениями с другими объектами

* Диаграмма классов является дальнейшим развитием концептуально модели проектируемой системы

### Класс

Класс (class) в языке UML служит для обозначения множества объектов, которые обладают одинаковой структурой, поведением и отношениями с объектами из других классов.

Графически класс изображается в виде прямоугольника, который дополнительно может быть разделен горизонтальными линиями на разделы или секции:
![[Pasted image 20250918011523.png]]
Обязательным элементом обозначения класса является его имя

Обязательным элементом обозначения класса является его имя.

На начальных этапах разработки диаграммы отдельные классы могут обозначаться простым прямоугольником с указанием только имени соответствующего класса.

По мере проработки отдельных компонентов диаграммы описания классов дополняются атрибутами и операциями.
![[Pasted image 20250918011534.png]]
Имя класса должно быть уникальным в пределах пакета, который описывается некоторой совокупностью диаграмм классов (возможно, одной диаграммой).

Рекомендуется в качестве имен использовать существительные, записанные по практическим соображениям без пробелов.

Именно имена классов образуют словарь предметной области при ООАП

### Абстрактный класс

Класс может не иметь экземпляров или объектов. В этом случае он называется абстрактным классом, а для обозначения его имени используется наклонный шрифт (курсив):

В языке UML принято общее соглашение о том, что любой текст, относящийся к абстрактному элементу, записывается курсивом.

#### Атрибуты класса

В языке UML принята стандартная запись атрибутов класса.

Каждому атрибуту соответствует отдельная строка текста, которая состоит из квантора видимости атрибута, имени атрибута, его кратности, типа значений атрибута и, возможно, его исходного значения.

Квантор видимости может принимать одно из трех возможных значений и отображается при помощи специальных символов:

* символ «+» обозначает атрибут с областью видимости типа общедоступный (public);
* символ «#» обозначает атрибут с областью видимости типа защищенный (protected);
* символ «-» обозначает атрибут с областью видимости типа закрытый (private).

**Пример использования кванторов видимости**:
	* Квантор видимости может быть опущен. В этом случае его отсутствие означает, что видимость атрибута не указывается.
	* Эта ситуация отличается от принятых по умолчанию соглашений в традиционных языках программирования, когда отсутствие квантора видимости трактуется как public или private.
	* Имя атрибута представляет собой строку текста, которая используется в качестве идентификатора соответствующего атрибута и должна быть уникальной в пределах данного класса.
	* Кратность атрибута характеризует общее количество конкретных атрибутов данного типа, входящих в состав отдельного класса.
	* Кратность записывается в форме строки текста в квадратных скобках после имени соответствующего атрибута.
	* Тип атрибута представляет собой выражение, семантика которого определяется языком спецификации соответствующей модели.

В нотации UML тип атрибута иногда определяется в зависимости от языка программирования, который предполагается использовать для реализации данной модели.

**Примеры типов атрибутов классов**:
* цвет:Color – здесь цвет является именем атрибута. Color – именем типа данного атрибута;
* имя_сотрудника[1..2]: String – здесь имя_сотрудника является именем атрибута, который служит для представления информации об имени (и отчестве) сотрудника.
* видимость:Boolean – здесь видимость есть имя абстрактного атрибута (курсив), который может характеризовать наличие визуального представления соответствующего класса на экране монитора.

Исходное значение служит для задания некоторого начального значения для соответствующего атрибута в момент создания отдельного экземпляра класса.

Если исходное значение не указано, то значение соответствующего атрибута не определено на момент создания нового экземпляра класса.

Операция

Операция представляет собой некоторый сервис, предоставляющий каждый экземпляр класса по определенному требованию.

Совокупность операций характеризует функциональный аспект поведения класса.

**Каждой операции класса соответствует строка**, состоящая из:
	* квантора видимости операции;
	* имени операции;
	* выражения типа возвращаемого операцией значения;
	* строка-свойство данной операции.

**Статический класс** – класс, в котором только статические поля и методы и на основе которого не создаются объекты

Чтобы показать на диаграмме что наш класс статический нужно добавить к имени модификатор Utility

Формально такие модификаторы называются стереотипами

**Стереотип** — это именованный набор свойств

В данном случае Utility указывает на то что объекты указанного класса не могут создаваться

Для повышения производительности одни операции могут выполняться параллельно или одновременно, а другие – только последовательно.

 * Для указания параллельности выполнения операции используется строка-свойство вида «{concurrency=имя}», где имя принимает следующие значения:
	 * последовательная (sequential);
	 * параллельная (concurrent);

**охраняемая** (guarded) – все обращения к данной операции должны быть строго упорядочены во времени с целью сохранения целостности объектов этого класса.

### Примеры записи операций:

* **+создать()** – операция по созданию отдельного объекта класса, которая является общедоступной и не содержит формальных параметров;
* **+нарисовать(форма:Многоугольник = прямоугольник, цвет_заливки:Color = (0,0,255))** – может обозначать операцию по изображению на экране монитора прямоугольной области синего цвета;
* **+запросить_счет_клиента(номер_счета: Integer):Currency** – обозначает операцию по установлению наличия средств на текущем счете клиента банка.

### Базовыми отношениями между классами в языке UML являются:

* Отношение зависимости (dependency relationship);
* Отношение ассоциации (association relationship);
* Отношение обобщения (generalization relationship);
* Отношение реализации (realization relationship).
* Отношение агрегации
* Отношение композиции

### Отношение зависимости

Отношение зависимости в общем случае указывает некоторое семантическое отношение между двумя классами, которое не является отношением ассоциации, обобщения или реализации.

Отношение зависимости используется в ситуациях, когда изменение одного элемента модели может потребовать изменения другого зависимого от него элемента модели.

Отношение зависимости графически изображается пунктирной линией между соответствующими элементами со стрелкой на одном из её концов.

На диаграмме классов стрелка направлена от класса-клиента зависимости к используемому классу или классу-источнику.

Стрелка может помечаться набивателями, но стандартным ключевым словом в кавычках и набивателями индивидуальным именем.

* Для отношения зависимости предусмотрены ключевые слова, которые обозначают некоторые стандартные виды зависимости (stereotype):
	* «access» – служит для обозначения доступности атрибутов и операций в спецификации класса-источника для класса-клиента;
	* «derive» – атрибуты класса-элемента могут быть выведены по атрибутам класса-источника;
	* «refine» – указывает, что класс-элемент служит уточнением класса-источника в силу причин исторического характера.

*  «bind» – класс-клиент может использовать некоторый шаблон для своей последующей параметризации;
*  «import» – открытые атрибуты и операции класса-источника становятся частью класса-элемента, как если бы они были объявлены непосредственно в нём.
![[Pasted image 20250918011737.png]]
### Отношение ассоциации

* Отношение ассоциации соответствует наличию некоторого отношения между классами. Данное отношение обозначается сплошной линией с дополнительными специальными символами:
	* имя ассоциации;
	* имена и кратность классов-ролей ассоциации.

Имя ассоциации является необязательным элементом её обозначения.

Наиболее простой случай – бинарная ассоциация.  
Она связывает в точности два класса и, как исключение, класс с самим собой.

**Пример бинарной ассоциации** – отношение между классами «Компания» и «Сотрудник».
![[Pasted image 20250918011819.png]]
### Отношение агрегации

Отношение агрегации имеет место между несколькими классами в том случае, если один из классов представляет собой некоторую сущность, включающую в себя в качестве составных частей другие сущности.

Используется для описания структуры сложных систем, т.е. применяется для представления взаимосвязей типа «целое–часть».

**Пример** отношения агрегации является взаимосвязь между сущностью «Грузовой автомобиль» и компонентами «Двигатель», «Шасси», «Кабина», «Кузов».

Графически отношение агрегации изображается сплошной линией, один из концов которой представляет собой незакрашенный ромб.

Ромб указывает на тот из классов, который представляет собой «целое». Остальные классы являются его «частями».

**Примером** отношения агрегации может служить деление персонального компьютера на составные части: системный блок, монитор, клавиатуру и мышь.

Используя обозначения языка UML, компонентный состав ПК можно представить в виде диаграммы классов.
![[Pasted image 20250918011828.png]]
### Отношение композиции

Отношение композиции является частным случаем отношения агрегации.

Это отношение служит для выделения специальной формы отношения «часть–целое», при которой составные части в некотором смысле включаются внутрь целого.

**Ограничение**: части не могут выступать в отрыве от целого, т.е. с уничтожением целого уничтожаются и все его составные части.

Графически отношение композиции изображается сплошной линией, один из концов которой представляет собой закрашенный внутрь ромб.

Этот ромб указывает на тот из классов, который представляет собой класс-композицию или «целое».
![[Pasted image 20250918011834.png]]
В качестве дополнительных обозначений для отношений композиции и агрегации могут использоваться дополнительные обозначения, применяемые для отношений ассоциации: кратность, имя.

**Пример**:
![[Pasted image 20250918011840.png]]
### Отношение обобщения

Отношение обобщения является таксономическим отношением между более общим элементом и более частным или специальным элементом.

Данное отношение описывает иерархическое строение классов и их наследование их свойств и поведения.

На диаграммах отношение обобщения обозначается сплошной линией с треугольной стрелкой на одном из концов. Стрелка указывает на более общий класс.
![[Pasted image 20250918011953.png]]
На диаграмме может указываться несколько линий для одного отношения обобщения, что отражает его таксономический характер.

**Пример**: класс «Геометрическая фигура» (абстрактный класс) выступает в качестве суперкласса для подклассов «Прямоугольник», «Окружность», «Линия».
![[Pasted image 20250918012003.png]]
Рядом со стрелкой обобщения могут указываться стереотипы:
* «{complete}» – означает, что в данном отношении обобщения специфицированы все классы-потомки, и других классов-потомков у данного класса-предка быть не может.
	**Пример**: класс «Клиент банка» является предком для двух классов «Физическое лицо» и «Компания».
* «{disjoint}» – означает, что классы-потомки не могут содержать объектов, одновременно принадлежащих экземплярам двух или более классов (см. предыдущий пример).
* «{incomplete}» – означает случай, противоположный первому. Предполагается, что на диаграмме указаны не все классы-потомки;
* «{overlapping}» – означает, что отдельные экземпляры классов-потомков могут принадлежать одновременно нескольким классам.

**Пример изображения с ограничениями**:
![[Pasted image 20250918012012.png]]
![[Pasted image 20250918012026.png]]
