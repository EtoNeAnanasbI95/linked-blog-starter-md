# Кратенько
* Чистая архитектура это такой паттерн/стандарт структурирования кода и файловой системы проекта в целом,  в бэкенд фронтенд приложениях(но в них это отдельная история)
* Чистая арха подразумевает под собой несколько слоёв (грубо говоря папки в которых должен быть написан семантически соответствующий код)
## Многослойность
* Для эффективного построения программы, необходимо разделить ответсвенность между ее частями. Верхний уровень может обращаться к нижним, но не наоборот.

1. **User Interface (Presentation Layer)** отвечает за вывод готовой информации в пользователя:
	* MVC
	* API
2. **Application Layer** отвечает за бизнес логику:
	* Services
3. **Domain Layer (Model Layer)** отвечает за определение объектов бизнес логики:
	- ﻿﻿Entities
	- ﻿﻿Repository interfaces
4. **Infrastructure Layer** отвечает за реализацию интерфейсов взаимодействия с объектами бизнес логики:
	* Repositories
	* Cache
	* Message Brokers

# Более развёрнуто
Чистая архитектура строится вокруг принципа **независимости слоёв**.  
Каждый слой имеет строго определённую зону ответственности и минимальные знания о других слоях.  
Главная идея: **внешние детали зависят от внутренней бизнес-логики, а не наоборот**.  

## Основные принципы
* **Зависимости направлены внутрь** — верхние слои (UI, Infrastructure) зависят от нижних (Application, Domain), но не наоборот.  
* **Изоляция бизнес-логики** — доменные правила не должны быть связаны с конкретной базой данных, фреймворком или внешней системой.  
* **Интерфейсы вместо реализаций** — взаимодействие между слоями строится через абстракции, а конкретные реализации подставляются в инфраструктуре.  
* **Тестируемость** — изоляция слоёв позволяет легко тестировать бизнес-логику без необходимости поднимать БД или внешние сервисы.  
* **Долговечность** — при смене UI, базы данных или очередей сообщений бизнес-логика остаётся неизменной.  

## Слои подробнее
1. **User Interface (Presentation Layer)**  
   Отвечает за взаимодействие с пользователем или внешними системами. Может быть веб-интерфейс, API, CLI, мобильное приложение. Этот слой не содержит бизнес-правил, а только получает запросы и отображает результат.  

2. **Application Layer**  
   Управляет бизнес-процессами, но не содержит их самих. Здесь находятся сценарии использования (use cases), сервисы, которые orchestrate работу доменных объектов, а также интерфейсы портов для внешних взаимодействий.  

3. **Domain Layer**  
   Сердце приложения — бизнес-правила. Здесь определяются сущности, агрегаты, value objects и доменные события. Этот слой не зависит от инфраструктуры и не знает о внешних технологиях.  

4. **Infrastructure Layer**  
   Содержит детали реализации: базы данных, API-клиенты, брокеры сообщений, кеш. Здесь реализуются интерфейсы, которые были определены выше (например, репозитории). Этот слой можно менять без затрагивания бизнес-логики.  

---
Чистая архитектура не жёстко задаёт конкретные папки или названия, а диктует **принципы разделения ответственности** и **правила направленности зависимостей**.  
## Интерфейсы и абстракции
В чистой архитектуре интерфейсы играют ключевую роль: они позволяют слоям взаимодействовать, не зная о конкретных реализациях.  
Такой подход напрямую связан с принципами **SOLID**, в первую очередь:  

* **D — Dependency Inversion Principle (Принцип инверсии зависимостей)**  
  Высокоуровневые модули (бизнес-логика) не должны зависеть от низкоуровневых (база данных, HTTP-клиенты и т.д.). Оба типа модулей зависят от абстракций (интерфейсов).  

* **I — Interface Segregation Principle (Принцип разделения интерфейсов)**  
  Интерфейсы должны быть маленькими и чётко отражать контракт. Например, отдельный `IUserRepository` вместо громоздкого общего `IDatabaseRepository`.  

### Где располагать интерфейсы?
* **Domain Layer** — интерфейсы, которые описывают взаимодействие с бизнес-сущностями (например, `IOrderRepository`, `ICustomerRepository`). Эти интерфейсы определяют, *что нужно* домену, но не говорят, *как это реализовано*.  
* **Application Layer** — интерфейсы для сервисов прикладной логики (например, `INotificationService`, `IFileStorageService`). Они задают контракты для orchestration-логики, но реализации подключаются во внешнем слое.  
* **Infrastructure Layer** — здесь находятся конкретные реализации интерфейсов (например, `SqlOrderRepository`, `S3FileStorageService`).  

Таким образом, интерфейсы концентрируются «внутри», ближе к бизнес-логике, а реализация уходит «наружу».  

---
## Ключевая мысль
Интерфейсы — это «границы» между слоями. Они обеспечивают слабую связанность кода, тестируемость и гибкость.  
Следуя принципам SOLID и правильно распределяя интерфейсы по слоям, можно строить систему, которую легко поддерживать и развивать.