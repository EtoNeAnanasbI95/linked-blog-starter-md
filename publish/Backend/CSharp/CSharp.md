# База

## Using

- Работает с объектами реализующими интерфейс IDisposable, и является грубой аналогией try finnaly. Короче эта штука нужна, когда ты работаешь с чем-то за пределами дотнета, например файлик из системы в работу берёшь, и тебе надо по окончанию каких-то действий с ним, сказать что он типа свободен и можно его брать

## Out и ref

- короче реф это операция взятия ссылки именно на переменную, то есть если создать экземпляр класса и назвать его Zhopa, и сделать реф, то грубо говоря это будет ссылка на ссылку на хип. И можно будет типа сколько угодно переинициализировать эту переменную, в функции куда она попадает в качестве аргумента. Аут работает так же, но перед тем как закинуть переменную в аргумент, не обязательно её инициализровать

## IEnumerable

- Просто перечисление, мы просто можем по нему бродить используя foreach, потому что там каждый объект является ссылкой к следующему объекту. В сути своей, когда мы объявляем линк запрос, мы изначально получаем енумерабл, который ещё ничего не отфильтровал, но подхватил ссылку на наш исходный лист, и сохранил в памяти инструкцию того, что надо сделать с этим листов, запустится эта инструкция только в момент обращения к переменной енумерабл

```csharp
List<int> numbers = new List<int> { 1, 2, 3, 4, 5 };
IEnumerable<int> filtered = numbers.Where(x => {
    Console.WriteLine($"Проверяю {x}");    
    return x > 3;
});
foreach (var num in filtered) {
    Console.WriteLine($"Вывожу {num}");
    if (num == 4) break; // Прерываем после 4
}

Проверяю 1
Проверяю 2
Проверяю 3
Проверяю 4
Вывожу 4
```

## IQueryable

- IQueryable:
    - Фильтрация происходит на источнике данных, а не в памяти.
    - Вместо того чтобы грузить все данные и фильтровать их в C#, IQueryable превращает твой запрос в инструкцию (например, SQL) и отправляет её базе данных.
    - Пример:

```csharp
using (var context = new MyDbContext())
{
    IQueryable<int> query = context.Numbers.Where(x => x > 3);
    var result = query.ToList();
}
```

- Тут Where превратится в SQL вроде SELECT * FROM Numbers WHERE Value > 3, и база вернёт только 4 и 5.

## Базовая теория

- Все классы в c# наследуются от класса object, который имеет методы ToString(), GetType(), GetHashCode(), Equals()
    - ToString — по умолчанию возвращает полный путь до неймспейса класса (название типа)
    - GetType — возвращает переменную типа Type, которая внутри себя хранит значение типа класса у которого вызвали этот метод
    - GetHashCode — возвращает хэш код (грубо говоря ссылку на адрес из кучи)
    - Equals — принимает в себя аргумент типа object и сравнивает экземпляры классов (по умолчанию сравнивает по хэш коду)
    
    > функции можно заоверрайдить
    > 

## Классы и структуры

- Класс = ссылочный
    
    ```csharp
    var  a = new Class1();
    var b = a;
    
    if (a.GetHashCode() == b.GetHashCode())
    {
        Console.WriteLine("equal reference"); // и это выведется, потому что так работают классы
    }
    ```
    
- Структура = значимый

## Ссылочные и значимые типы данных

- Ссылочные — те типы, которые хранятся в куче
- значимые — те типы, которые хранятся в стэке, но не всегда (см. боксинг/анбоксинг)

### Боксинг/анбоксинг

- Если мы внутри класса определяем структуру, то получается что структура хранится в классе, а класс хранится в куче. В итоге структура технически валяется в куче

## Интерфейсы и абстрактные классы

- Интерфейсы и абстрактные классы отличаются друг от друга в основном философией, потому. Абстрактный класс создан с целью создать какую-то базовую/абстрактную реализацию для дочерних классов, например каких-нибудь репозиториев или сервисов. Так же он имеет особенность, нельзя создать экземпляр абстрактного класса, в отличии от обычного класса и интерфейса
- Интерфейсы это больше история, когда мы какие-то классы наделяем каким-то характеристиками, условный класс ModelOne будет наследоваться от интерфейса IRunnable, который содержит в себе объявление функции run. Получается что класс ModelOne должен будет имплементировать интерфейс IRunnable, тем самым гарантируя факт реализации какой-то характеристики. Или же интерфейсы можно объяснить на примере книг, где сама книга это класс, а интерфейс это её оглавление. Когда мы открываем книгу и ищем какую-то конкретную главу, мы просто смотрим в оглавление и находим её в книге, тут точно так же, нам нужен метод run, и мы знаем что класс наследуется от интерфейса IRunnable, что означает что мы можем написать функцию, которая будет принимать IRunnable и запускать тот самый метод run

## События

- Что типа триггера, после срабатывания которого может вызываться какой-то делегат

## Делегаты

- Грубо говоря ссылка на метод, которую можно передать как аргумент в какую-то функцию. Бывают нескольких видов:
    - Action — возвращает void
    - Func — возвращает какое-то значение

## Исключения

- Штука которую мы выбрасываем или получаем во время исполнения или компиляции кода

# Асинхронное программирование

## Примитивы

### lock

- Он нужен, когда у тебя есть **многопоточность** (несколько потоков работают одновременно) и они лезут в одно и то же место в памяти, например, в общую переменную или список. Без lock они могут всё сломать:
    - Один поток читает данные, а другой в это время их меняет — получаешь кашу.
    - Два потока одновременно пишут в одну переменную — результат непредсказуемый.
    
    lock решает эту проблему, заставляя потоки работать по очереди.
    
    ```csharp
    class Program
    {
        static int counter = 0;
        static object lockObject = new object(); // Это наш "замок"
        
        static void Main()
        {
            Thread thread1 = new Thread(IncrementCounter);
            Thread thread2 = new Thread(IncrementCounter);
            
            thread1.Start();
            thread2.Start();
            
            thread1.Join();
            thread2.Join();
            
            Console.WriteLine(counter); // Должно быть 200, а не случайное число
        }
        
        static void IncrementCounter()
        {
            for (int i = 0; i < 100; i++)
            {
                lock (lockObject)
                {
                    counter++; // Только один поток может тут работать
                }
            }
        }
    }
    ```
    
- **Дедлоки (deadlock)**
    - Если два потока ждут друг друга из-за lock, программа зависнет. Например:
    
    ```csharp
    lock (obj1)
    {
        lock (obj2) { ... } // Поток 1 ждёт obj2
    }
    lock (obj2)
    {
        lock (obj1) { ... } // Поток 2 ждёт obj1
    }
    ```
    

## Параллельность и Асинхронное программирование

# ASP.net

# LINQ

## Расширения

- Методы select, where и другие называются расширениями, они являются статическими методами в классе Enumerable они "приклеиваются" к коллекциям благодаря ключевому слову this в их определении, а так же являются статическими. Эти самые расширения можно писать самому

```csharp
public static class IntExtensions
{
    public static int Double(this int number)
    {
        return number * 2;
    }
}

class Program
{
    static void Main()
    {
        int num = 5;
        int doubled = num.Double(); // Вернёт 10
        Console.WriteLine(doubled);
    }
}
```

## Разница между select и where

- Select нужен для изменения данных в коллекции, а where для их фильтрации. То есть если в where в лямбду мы пропишем просто условие, которое должно выполняться для итерируемого объекта, то в селект мы напишем что надо сделать с этим объектом

```csharp
List<int> numbers = new List<int> { 1, 2, 3, 4, 5 };
var bigNumbers = numbers.Where(x => x > 3); // Вернёт 4, 5

List<int> numbers = new List<int> { 1, 2, 3, 4, 5 };
var doubledNumbers = numbers.Select(x => x * 2); // Вернёт 2, 4, 6, 8, 10
```

# EntityFramework

## Особенности

- Вся работа с реализуется через линк запросы, но если обычные линк запросы зачастую используют под собой Енумерабл, то EntityFramework использует Айквариебл