# Основы
## Ссылочные и значимые типы данных
- Ссылочные — те типы, которые хранятся в куче
- значимые — те типы, которые хранятся в стэке, но не всегда (см. боксинг/анбоксинг)
### Боксинг/анбоксинг
- Если мы внутри класса определяем структуру, то получается что структура хранится в классе, а класс хранится в куче. В итоге структура технически валяется в куче
## Классы и структуры
- Класс = ссылочный   
    ```csharp
    var  a = new Class1();
    var b = a;
    
    if (a.GetHashCode() == b.GetHashCode())
    {
        Console.WriteLine("equal reference"); // и это выведется, потому что так работают классы
    }
    ```
- Структура = значимый
## Базовая теория
- Все классы в c# наследуются от класса object, который имеет методы ToString(), GetType(), GetHashCode(), Equals()
    - ToString — по умолчанию возвращает полный путь до неймспейса класса (название типа)
    - GetType — возвращает переменную типа Type, которая внутри себя хранит значение типа класса у которого вызвали этот метод
    - GetHashCode — возвращает хэш код (грубо говоря ссылку на адрес из кучи)
    - Equals — принимает в себя аргумент типа object и сравнивает экземпляры классов (по умолчанию сравнивает по хэш коду)

> [!INFO] Info
> Функции можно заоверрайдить
## Out и ref
- короче реф это операция взятия ссылки именно на переменную, то есть если создать экземпляр класса и назвать его Zhopa, и сделать реф, то грубо говоря это будет ссылка на ссылку на хип. И можно будет типа сколько угодно переинициализировать эту переменную, в функции куда она попадает в качестве аргумента. Аут работает так же, но перед тем как закинуть переменную в аргумент, не обязательно её инициализровать

## Using
- Работает с объектами реализующими интерфейс IDisposable, и является грубой аналогией try finnaly. Короче эта штука нужна, когда ты работаешь с чем-то за пределами дотнета, например файлик из системы в работу берёшь, и тебе надо по окончанию каких-то действий с ним, сказать что он типа свободен и можно его брать

## Делегаты
- Грубо говоря ссылка на метод, которую можно передать как аргумент в какую-то функцию. Бывают нескольких видов:
    - Action — возвращает void
    - Func — возвращает какое-то значение

## Исключения
- Штука которую мы выбрасываем или получаем во время исполнения или компиляции кода

## События
- Что типа триггера, после срабатывания которого может вызываться какой-то делегат
## Интерфейсы и абстрактные классы
- Интерфейсы и абстрактные классы отличаются друг от друга в основном философией, потому. Абстрактный класс создан с целью создать какую-то базовую/абстрактную реализацию для дочерних классов, например каких-нибудь репозиториев или сервисов. Так же он имеет особенность, нельзя создать экземпляр абстрактного класса, в отличии от обычного класса и интерфейса
- Интерфейсы это больше история, когда мы какие-то классы наделяем каким-то характеристиками, условный класс ModelOne будет наследоваться от интерфейса IRunnable, который содержит в себе объявление функции run. Получается что класс ModelOne должен будет имплементировать интерфейс IRunnable, тем самым гарантируя факт реализации какой-то характеристики. Или же интерфейсы можно объяснить на примере книг, где сама книга это класс, а интерфейс это её оглавление. Когда мы открываем книгу и ищем какую-то конкретную главу, мы просто смотрим в оглавление и находим её в книге, тут точно так же, нам нужен метод run, и мы знаем что класс наследуется от интерфейса IRunnable, что означает что мы можем написать функцию, которая будет принимать IRunnable и запускать тот самый метод run

## Итераторы
### IEnumerable
- Просто перечисление, мы просто можем по нему бродить используя foreach, потому что там каждый объект является ссылкой к следующему объекту. В сути своей, когда мы объявляем линк запрос, мы изначально получаем енумерабл, который ещё ничего не отфильтровал, но подхватил ссылку на наш исходный лист, и сохранил в памяти инструкцию того, что надо сделать с этим листов, запустится эта инструкция только в момент обращения к переменной енумерабл
```csharp
List<int> numbers = new List<int> { 1, 2, 3, 4, 5 };
IEnumerable<int> filtered = numbers.Where(x => {
    Console.WriteLine($"Проверяю {x}");    
    return x > 3;
});
foreach (var num in filtered) {
    Console.WriteLine($"Вывожу {num}");
    if (num == 4) break; // Прерываем после 4
}

Проверяю 1
Проверяю 2
Проверяю 3
Проверяю 4
Вывожу 4
```
### IQueryable
- IQueryable:
    - Фильтрация происходит на источнике данных, а не в памяти.
    - Вместо того чтобы грузить все данные и фильтровать их в C#, IQueryable превращает твой запрос в инструкцию (например, SQL) и отправляет её базе данных.
    - Пример:
```csharp
using (var context = new MyDbContext())
{
    IQueryable<int> query = context.Numbers.Where(x => x > 3);
    var result = query.ToList();
}
```
- Тут Where превратится в SQL вроде SELECT * FROM Numbers WHERE Value > 3, и база вернёт только 4 и 5.

## Расширения
---
- Методы select, where и другие называются расширениями, они являются статическими методами в классе Enumerable они "приклеиваются" к коллекциям благодаря ключевому слову this в их определении, а так же являются статическими. Эти самые расширения можно писать самому
```csharp
public static class IntExtensions
{
    public static int Double(this int number)
    {
        return number * 2;
    }
}

class Program
{
    static void Main()
    {
        int num = 5;
        int doubled = num.Double(); // Вернёт 10
        Console.WriteLine(doubled);
    }
}
```
---
* Расширения (extension) — это **статические методы в статических классах**, которые позволяют добавлять функциональность к существующим типам без их модификации. Это особенно удобно, если ты привык к **цепочкам методов** в TypeScript (например, .map().filter()). Расширения делают код чище, читабельнее и поддерживают принцип **инкапсуляции**, позволяя вынести вспомогательную логику в отдельные модули.

### Зачем нужны расширения?
- **Улучшают читаемость**: Вместо громоздких утилитных классов ты можешь вызывать методы прямо на объекте, как будто они встроены.
- **Инкапсуляция**: Логика, связанная с конкретным типом, группируется в одном месте.
- **Переиспользование**: Расширения легко использовать в разных частях проекта или даже в разных проектах.
- **Совместимость с цепочками**: Если ты любишь fluent API (как в LINQ или в TS), расширения идеально вписываются в этот стиль.
### Как это работает?
* Расширения — это статические методы в статическом классе, где первый параметр помечен ключевым словом this. Это указывает, к какому типу метод "приклеивается". Например, методы LINQ (Select, Where) — это расширения из класса Enumerable, которые "приклеены" к **IEnumerable<>**
### Пример 1: Простое расширение для int
```c#
public static class IntExtensions
{
    public static int Double(this int number)
    {
        return number * 2;
    }
}

class Program
{
    static void Main()
    {
        int num = 5;
        int doubled = num.Double(); // Вызов как будто метод встроен в int
        Console.WriteLine(doubled); // Выведет: 10
    }
}
```
### Пример 2: Расширение для WebApplicationBuilder в ASP.NET Core
* В проектах на ASP.NET Core часто используют **расширения** для **настройки WebApplicationBuilder**. Это позволяет вынести конфигурацию сервисов, middleware или других компонентов в отдельные методы, делая Program.cs чище и модульнее
```c#
public static class WebApplicationBuilderExtensions
{
    public static WebApplicationBuilder AddCustomLogging(this WebApplicationBuilder builder)
    {
        builder.Services.AddLogging(logging =>
        {
            logging.ClearProviders();
            logging.AddConsole();
            logging.AddDebug();
            logging.SetMinimumLevel(LogLevel.Information);
        });
        return builder; // Возвращаем builder для поддержки цепочек
    }
}

class Program
{
    static void Main(string[] args)
    {
        var builder = WebApplication.CreateBuilder(args);

        // Используем расширение для настройки логирования
        builder.AddCustomLogging();

        // Добавляем другие сервисы
        builder.Services.AddControllers();

        var app = builder.Build();
        app.UseRouting();
        app.MapControllers();
        app.Run();
    }
}
```
### Почему это лучше?
- **Чистый код**: Вместо того чтобы писать длинную конфигурацию в Program.cs, ты выносишь её в отдельный метод. Это как в Go, где ты бы вынес конфигурацию в отдельную функцию для читаемости.
- **Модульность**: Расширения можно хранить в папке Extensions, как в твоём проекте, и переиспользовать в других местах.
- **Fluent API**: Возвращая builder, ты поддерживаешь цепочки вызовов, как в TypeScript (app.use().use()).
- **Тестируемость**: Логика настройки изолирована, что упрощает тестирование.
### Когда использовать?
- Когда хочешь добавить функциональность к классам, которые не можешь изменить (например, WebApplicationBuilder или IEnumerable<>).
- Когда нужно сделать API более интуитивным и выразительным.
- Когда хочешь вынести повторяющуюся логику в переиспользуемый код.

# Асинхронное программирование
## Примитивы
### Lock
- Он нужен, когда у тебя есть **многопоточность** (несколько потоков работают одновременно) и они лезут в одно и то же место в памяти, например, в общую переменную или список. Без lock они могут всё сломать:
    - Один поток читает данные, а другой в это время их меняет — получаешь кашу.
    - Два потока одновременно пишут в одну переменную — результат непредсказуемый.
    
    Lock решает эту проблему, заставляя потоки работать по очереди.
    ```csharp
    class Program
    {
        static int counter = 0;
        static object lockObject = new object(); // Это наш "замок"
        
        static void Main()
        {
            Thread thread1 = new Thread(IncrementCounter);
            Thread thread2 = new Thread(IncrementCounter);
            
            thread1.Start();
            thread2.Start();
            
            thread1.Join();
            thread2.Join();
            
            Console.WriteLine(counter); // Должно быть 200, а не случайное число
        }
        
        static void IncrementCounter()
        {
            for (int i = 0; i < 100; i++)
            {
                lock (lockObject)
                {
                    counter++; // Только один поток может тут работать
                }
            }
        }
    }
    ```
- **Дедлоки (deadlock)**
    - Если два потока ждут друг друга из-за lock, программа зависнет. Например:
    ```csharp
    lock (obj1)
    {
        lock (obj2) { ... } // Поток 1 ждёт obj2
    }
    lock (obj2)
    {
        lock (obj1) { ... } // Поток 2 ждёт obj1
    }
    ```