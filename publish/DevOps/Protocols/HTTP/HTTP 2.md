# Объяснение
## HTTP/2 (2015)
### Одно TCP-соединение
#### 1. Что делает браузер, когда ты пишешь `fetch(...)`
Представь у тебя на сайте 6 `fetch("https://api.parasha.com/...")`.
В старом HTTP/1.1:
- На каждый запрос браузер пытался открыть своё TCP (или использовать уже существующее, но там очередь).
- В итоге реально 6 TCP-соединений параллельно.
В HTTP/2:
- Когда браузер впервые делает запрос на `https://api.parasha.com`, он устанавливает **одно TCP-соединение** и договаривается с сервером о переходе в протокол HTTP/2 (через TLS-расширение ALPN).
- Теперь у браузера и сервера есть **одна труба (TCP socket)**.
- Каждый новый `fetch(...)` не открывает новую трубу, а регистрирует **новый поток (stream)** внутри этого соединения.
#### 2. Как выглядит "одно соединение с многими запросами"
TCP сам по себе не умеет в «много логических каналов».  
Эту фичу добавил HTTP/2:
- Все запросы и ответы разбиваются на маленькие кусочки (фреймы).
- У каждого фрейма есть **Stream ID** — номер логического канала.
- Клиент и сервер знают: если `Stream ID=1` → это HTML, `Stream ID=3` → это CSS, `Stream ID=5` → это твой первый fetch.
В итоге, через одну трубу TCP летят вперемешку такие кусочки:
```
[stream 1: HTML part1]
[stream 3: CSS part1]
[stream 5: API#1 response part1]
[stream 7: API#2 response part1]
[stream 5: API#1 response part2]
[stream 7: API#2 response part2]
...
```
> [!INFO] Резюме:
> Браузер потом собирает куски с одинаковым Stream ID и отдаёт их твоему `fetch`.

#### 3. То есть магии нет
- В коде у тебя **шесть разных fetch-запросов**.
- В браузере это превращается в **шесть HTTP/2-потоков**.
- В TCP на уровне пакетов это выглядит как перемешанные куски данных.
- Но благодаря Stream ID они не путаются.
#### 4. Сравнение в картинках (ASCII)
**HTTP/1.1:**
```
TCP#1: GET /api/1  -> ответ1
TCP#2: GET /api/2  -> ответ2
TCP#3: GET /api/3  -> ответ3
TCP#4: GET /api/4  -> ответ4
TCP#5: GET /api/5  -> ответ5
TCP#6: GET /api/6  -> ответ6
```
**HTTP/2 (одно соединение):**
```
TCP#1:
  Stream1 -> /api/1
  Stream3 -> /api/2
  Stream5 -> /api/3
  Stream7 -> /api/4
  Stream9 -> /api/5
  Stream11 -> /api/6
```
> [!INFO] Резюме:
> Все фреймы перемешаны, но у каждого свой номер потока → браузер знает, к какому fetch относится кусок.
#### 5. Почему это реально быстрее?
- Не надо заново открывать TCP/TLS (экономия 1-2 RTT на каждый запрос).
- Нет блокировок «один запрос ждёт другой».
- Всё летит параллельно через одну трубу.
### Бинарный протокол (эффективнее, чем текстовый).
**Как было раньше (HTTP/1.1):**
- Запрос и ответ были **текстовыми**.
- Пример:
```
GET /index.html HTTP/1.1
Host: parasha.com
User-Agent: Chrome
```
- Это легко читать человеку, но для компьютера — лишние байты и парсинг строк.
**В HTTP/2:**
- Всё превращается в **бинарные фреймы**.
- Например, заголовок `:method: GET` кодируется как маленький бинарный кусочек, а не как строка.
- Сервер и клиент работают с компактными структурами, а не с текстом.
### Мультиплексирование (несколько запросов и ответов одновременно).
**В HTTP/1.1:**
- По одному соединению шёл только **один активный ответ**.
- Если запрос завис → все остальные ждали (head-of-line blocking).
- Поэтому браузеры открывали по 6 TCP-соединений на домен.
**В HTTP/2:**
- В одном TCP-соединении может быть **много потоков (streams)**.
- Каждый запрос разбивается на фреймы, у каждого фрейма есть **Stream ID**.
- Фреймы разных потоков перемешиваются и идут параллельно.
- Браузер и сервер собирают их обратно.
> [!INFO] Резюме:
>  Это позволяет одновременно качать десятки файлов через одно соединение.

> [!NOTE] Ну типа...
> Типа это следствие того, что у нас теперь одно TCP подключение, а не 10
### Server Push (сервер может заранее отправить CSS/JS).
**Проблема в HTTP/1.1:**
- Клиент сначала получает HTML.
- Потом видит в нём `<link href="style.css">` → делает новый запрос.
- Потеря времени: нужно ждать HTML → потом делать запросы на CSS/JS.
**В HTTP/2:**
- Сервер может сказать:  
    «Я знаю, что после HTML тебе точно понадобится `style.css` и `app.js`. Я их сразу пушну вместе с ответом».
- Браузер получает эти ресурсы ещё до того, как сам их попросит.
> [!INFO] Резюме:
>  Итог: быстрее загрузка страницы (особенно первый рендер).
>
> **Но!**
>   - Сейчас Server Push мало где используют → сложный в настройке, часто мешает кэшированию.
>   - Многие CDN его даже отключили.
### Сжатие заголовков (HPACK).
**Почему это важно:**
- Каждый запрос и ответ содержит кучу заголовков (`User-Agent`, `Cookie`, `Accept-Language` и т.д.).
- Иногда только заголовки = десятки килобайт.
- В HTTP/1.1 они передавались полностью каждый раз.
**В HTTP/2:**
- Введён алгоритм **HPACK**:
    - Словарь часто встречающихся заголовков (например, `:method: GET`, `:scheme: https`).
    - Дельта-сжатие (если заголовок не изменился с прошлого запроса — просто укажи ссылку на его ID в таблице).
    - Бинарное кодирование вместо текста.
> [!INFO] Резюме:
>  Экономия: заголовки, которые раньше весили 1–2 КБ, теперь могут занимать всего десятки байт.