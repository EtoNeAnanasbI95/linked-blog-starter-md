# Вкратце
* HTTP 3 — это тот же самый протокол прикладного уровня (методы GET/POST, заголовки, JSON и т.п.),  но работает он уже **не поверх TCP**, а поверх **QUIC (UDP)**.
# Объяснение
## Проблема TCP (почему нужен был новый транспорт)
В HTTP/2 всё классно: мультиплексирование, бинарные фреймы и пр.  
НО оно всё сидит внутри **одного [[❌ TCP]]-соединения**.
А TCP работает так:
- Данные передаются как последовательный поток байтов.
- Если потерялся хоть один пакет → TCP ждёт, пока он дойдёт, прежде чем отдать следующие.
- Это называется **head-of-line blocking (HOL blocking)**:
```
[Пакет1][Пакет2][Пакет3]
Потерялся пакет2 → пока он не придёт, браузер не получит пакет3, хотя он уже в очереди.
```    

> [!INFO] Поэтому
> В HTTP/2 это больно, потому что внутри одного TCP могут ехать десятки параллельных потоков → один потерянный пакет стопорит всё.
> Потому в HTTP 3 стали использовать [[❌ QUIC]]
## [[❌ QUIC]] — решение (и основа HTTP/3)
[[❌ QUIC]] = новый транспортный протокол от Google.
- Работает поверх **UDP** (а не TCP).
- В нём реализованы «свои TCP+TLS», но в улучшенной версии.
**Что даёт [[❌ QUIC]]:**
1. **Мультиплексирование потоков на транспортном уровне**:
    - В отличие от [[❌ TCP]], [[❌ QUIC]] не смешивает всё в один байтовый поток.
    - У каждого потока свой независимый буфер.
    - Потерялся пакет потока A → это не мешает потоку B.
2. **Быстрое установление соединения**:
    - TCP+TLS требует несколько «рукопожатий» (RTT), чтобы начать передачу.
    - В QUIC встроен **TLS 1.3** → можно начать защищённую передачу за **0–1 RTT**.
3. **Лучше работает в мобильных сетях**:
    - В TCP, если IP изменился (например, перешёл с Wi-Fi на 4G), нужно пересоздавать соединение.
    - В QUIC соединение привязывается к **идентификатору**, а не к IP → можно «переехать» на другой IP без разрыва соединения.
## Как выглядит HTTP/3 поверх QUIC
```
HTTP/3 → QUIC → UDP → IP
```
Внутри [[❌ QUIC]]:
- Есть потоки (streams), как в HTTP/2.
- Есть встроенное шифрование ([[❌ TLS]] 1.3).
- Есть контроль потока и исправление потерь, но на уровне каждого отдельного потока.
## Сравнение HTTP/2 и HTTP/3
**HTTP/2 (TCP):**
```
TCP (один поток байтов)
   ├─ Stream1 (HTML)
   ├─ Stream3 (CSS)
   └─ Stream5 (JS)

Потерялся пакет TCP → стопорятся все стримы
```
**HTTP/3 (QUIC/UDP):**
```
UDP (QUIC поверх него)
   ├─ Stream1 (HTML)   ← потерялся кусок → тормозит только HTML
   ├─ Stream3 (CSS)    ← идёт дальше
   └─ Stream5 (JS)     ← идёт дальше
```

## Преимущества HTTP/3
- Быстрее устанавливается соединение (0-RTT / 1-RTT).
- Идеален для мобильных сетей (смена IP не рвёт соединение).
- Нет глобального head-of-line blocking.
- Встроенное шифрование (TLS 1.3 обязательно, без «http://» не бывает).
## Недостатки HTTP/3
- Сложнее реализовать (QUIC сильно сложнее TCP).
- Не все прокси/фаерволы умеют работать с QUIC (некоторые блокируют UDP).
- Поддержка в серверах и клиентах появилась относительно недавно, но уже активно распространяется (Cloudflare, Google, большинство браузеров).
## Пример жизни
Ты заходишь на сайт `parasha.com`, где включён HTTP/3:
1. Браузер договаривается с сервером по QUIC (через UDP, сразу с шифрованием TLS 1.3).
2. Внутри создаётся несколько потоков:
    - Stream 1 → HTML
    - Stream 3 → CSS
    - Stream 5 → JS
    - Stream 7 → API-запрос
3. Если у тебя лаганул Wi-Fi и потерялись пакеты с CSS → HTML и JS продолжают грузиться без проблем.
## Итог
HTTP/3 — это:
- Тот же HTTP, что и раньше (методы GET/POST, заголовки, JSON).
- Но транспорт другой: **QUIC (UDP + TLS 1.3 + мультиплексирование без блокировок)**.
- Решает старую боль HTTP/2 → head-of-line blocking.
- Оптимизирован для современных условий: мобильный интернет, потери пакетов, быстрый старт.
