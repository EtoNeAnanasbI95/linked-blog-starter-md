# Кратенько
HTTP 1.1 появился в **1997 году** (RFC 2068 → потом RFC 2616) и стал **де-факто стандартом интернета** на десятилетия.  
Все сайты, которые мы знаем с «раннего интернета» — Google, YouTube, соцсети — сначала строились именно на нём.
# Объяснение
## Как это работает (базово)
- HTTP/1.1 работает поверх **TCP** (а TCP поверх IP).
- Запросы и ответы передаются **в текстовом виде** (ASCII).
- Каждый запрос содержит строку и заголовки:
    ```
    GET /index.html HTTP/1.1
    Host: parasha.com
    User-Agent: Chrome
    Accept: text/html
    ```
- Сервер отвечает:
    ```
    HTTP/1.1 200 OK
    Content-Type: text/html
    Content-Length: 1256
    ```
## Нововведения по сравнению с HTTP/1.0
1. **Persistent connections (Keep-Alive)**
    - В HTTP/1.0 каждое обращение = новое TCP-соединение.
    - В HTTP/1.1 соединение можно держать открытым и слать несколько запросов подряд.
2. **Пайплайнинг (pipelining)**
    - Можно послать несколько запросов подряд, не дожидаясь ответа на первый.
    - Но на практике не взлетело → серверы всё равно отвечали по порядку → head-of-line blocking оставался.
3. **Chunked transfer encoding**
    - Сервер может отправлять данные кусками, без знания полного размера заранее.
    - Например, для стриминга ответа.
4. **Host-заголовок (обязательный)**
    - Позволил на одном IP держать несколько сайтов (виртуальный хостинг).
    - Пример:
        ```
        Host: parasha.com
        ```
## Ограничения и проблемы
1. **Head-of-line blocking**
    - В одном соединении можно вести только **один активный запрос**.
    - Даже с пайплайнингом → сервер отвечает строго по порядку.
    - Потеря пакета TCP стопорит весь поток.
2. **Ограничение по числу соединений**
    - Чтобы обойти HOL-blocking, браузеры стали открывать **по 6 TCP-соединений на один домен**.
    - Поэтому сайты начали «шарить статику» по разным поддоменам (`img1.parasha.com`, `img2.parasha.com`).
3. **Большие заголовки**
    - Каждый запрос шлёт кучу заголовков (`Cookie`, `User-Agent` и т.д.).
    - Они не сжимаются и передаются каждый раз заново.
4. **Медленный старт**
    - TCP требует 3-way handshake.
    - TLS (для HTTPS) добавляет ещё пару RTT.
    - Поэтому первый запрос к сайту мог занимать сотни миллисекунд.
## Методы HTTP/1.1
Классические **методы запросов** появились именно здесь:
- `GET` — получить данные.
- `POST` — отправить данные (форма, JSON).
- `PUT` — заменить ресурс.
- `DELETE` — удалить ресурс.
- `PATCH` — частично обновить.
- `HEAD` — как `GET`, но только заголовки.
- `OPTIONS` — узнать, какие методы поддерживает сервер.
## Типичный сценарий в HTTP/1.1
1. Пользователь открывает `parasha.com`.
2. Браузер делает запрос:
    ```
    GET / HTTP/1.1
    Host: parasha.com
    ```
3. Сервер отвечает HTML.
4. В HTML есть ссылки на CSS, JS, картинки → браузеру нужно сделать **десятки новых запросов**.
5. Чтобы ускорить загрузку:
    - браузер открывает сразу 6 соединений,
    - сервер хранит их в Keep-Alive,
    - но всё равно каждый поток ждёт свой ответ.
## Почему его заменили
- Он держался **20+ лет**, но стал узким местом, когда сайты начали грузить сотни ресурсов.
- Ограничения TCP + текстовые заголовки + отсутствие нормального мультиплексинга → медленно.
- Решения-прокостыли:
    - «спрайты» (склеивали все иконки в один PNG),
    - минификация и бандлинг CSS/JS,
    - шардинг по поддоменам.
- Всё это костыли, которые HTTP/2 и HTTP/3 уже решают из коробки.
